/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import * as z from "zod/v4-mini";
import { safeParse } from "../lib/schemas.js";
import { Result as SafeParseResult } from "../types/fp.js";
import * as types from "../types/primitives.js";
import { SDKValidationError } from "./errors/sdkvalidationerror.js";

export type MessageContentContact = {
  name?: string | undefined;
  phones?: Array<string> | undefined;
};

export type Button = {
  id: string;
  title: string;
};

export type Row = {
  id: string;
  title: string;
  description?: string | undefined;
};

export type Section = {
  title: string;
  rows: Array<Row>;
};

/**
 * Content for non-text message types (WhatsApp only).
 */
export type MessageContent = {
  /**
   * URL of the media file (for image, video, audio, document, sticker).
   */
  mediaUrl?: string | undefined;
  /**
   * WhatsApp media ID if already uploaded.
   */
  mediaId?: string | undefined;
  /**
   * MIME type of the media.
   */
  mimeType?: string | undefined;
  /**
   * Filename for documents.
   */
  filename?: string | undefined;
  /**
   * Latitude for location messages.
   */
  latitude?: number | undefined;
  /**
   * Longitude for location messages.
   */
  longitude?: number | undefined;
  /**
   * Name of the location.
   */
  locationName?: string | undefined;
  /**
   * Address of the location.
   */
  locationAddress?: string | undefined;
  /**
   * Contact cards for contact messages.
   */
  contacts?: Array<MessageContentContact> | undefined;
  /**
   * Interactive buttons (max 3).
   */
  buttons?: Array<Button> | undefined;
  /**
   * Button text for list messages.
   */
  listButton?: string | undefined;
  /**
   * Sections for list messages.
   */
  sections?: Array<Section> | undefined;
  /**
   * Emoji for reaction messages.
   */
  emoji?: string | undefined;
  /**
   * Message ID to react to.
   */
  reactToMessageId?: string | undefined;
  /**
   * Template ID for template messages.
   */
  templateId?: string | undefined;
  /**
   * Variables for template rendering. Keys are variable positions (1, 2, 3...).
   */
  templateVariables?: { [k: string]: string } | undefined;
};

/** @internal */
export const MessageContentContact$inboundSchema: z.ZodMiniType<
  MessageContentContact,
  unknown
> = z.object({
  name: types.optional(types.string()),
  phones: types.optional(z.array(types.string())),
});
/** @internal */
export type MessageContentContact$Outbound = {
  name?: string | undefined;
  phones?: Array<string> | undefined;
};

/** @internal */
export const MessageContentContact$outboundSchema: z.ZodMiniType<
  MessageContentContact$Outbound,
  MessageContentContact
> = z.object({
  name: z.optional(z.string()),
  phones: z.optional(z.array(z.string())),
});

export function messageContentContactToJSON(
  messageContentContact: MessageContentContact,
): string {
  return JSON.stringify(
    MessageContentContact$outboundSchema.parse(messageContentContact),
  );
}
export function messageContentContactFromJSON(
  jsonString: string,
): SafeParseResult<MessageContentContact, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => MessageContentContact$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'MessageContentContact' from JSON`,
  );
}

/** @internal */
export const Button$inboundSchema: z.ZodMiniType<Button, unknown> = z.object({
  id: types.string(),
  title: types.string(),
});
/** @internal */
export type Button$Outbound = {
  id: string;
  title: string;
};

/** @internal */
export const Button$outboundSchema: z.ZodMiniType<Button$Outbound, Button> = z
  .object({
    id: z.string(),
    title: z.string(),
  });

export function buttonToJSON(button: Button): string {
  return JSON.stringify(Button$outboundSchema.parse(button));
}
export function buttonFromJSON(
  jsonString: string,
): SafeParseResult<Button, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => Button$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'Button' from JSON`,
  );
}

/** @internal */
export const Row$inboundSchema: z.ZodMiniType<Row, unknown> = z.object({
  id: types.string(),
  title: types.string(),
  description: types.optional(types.string()),
});
/** @internal */
export type Row$Outbound = {
  id: string;
  title: string;
  description?: string | undefined;
};

/** @internal */
export const Row$outboundSchema: z.ZodMiniType<Row$Outbound, Row> = z.object({
  id: z.string(),
  title: z.string(),
  description: z.optional(z.string()),
});

export function rowToJSON(row: Row): string {
  return JSON.stringify(Row$outboundSchema.parse(row));
}
export function rowFromJSON(
  jsonString: string,
): SafeParseResult<Row, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => Row$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'Row' from JSON`,
  );
}

/** @internal */
export const Section$inboundSchema: z.ZodMiniType<Section, unknown> = z.object({
  title: types.string(),
  rows: z.array(z.lazy(() => Row$inboundSchema)),
});
/** @internal */
export type Section$Outbound = {
  title: string;
  rows: Array<Row$Outbound>;
};

/** @internal */
export const Section$outboundSchema: z.ZodMiniType<Section$Outbound, Section> =
  z.object({
    title: z.string(),
    rows: z.array(z.lazy(() => Row$outboundSchema)),
  });

export function sectionToJSON(section: Section): string {
  return JSON.stringify(Section$outboundSchema.parse(section));
}
export function sectionFromJSON(
  jsonString: string,
): SafeParseResult<Section, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => Section$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'Section' from JSON`,
  );
}

/** @internal */
export const MessageContent$inboundSchema: z.ZodMiniType<
  MessageContent,
  unknown
> = z.object({
  mediaUrl: types.optional(types.string()),
  mediaId: types.optional(types.string()),
  mimeType: types.optional(types.string()),
  filename: types.optional(types.string()),
  latitude: types.optional(types.number()),
  longitude: types.optional(types.number()),
  locationName: types.optional(types.string()),
  locationAddress: types.optional(types.string()),
  contacts: types.optional(
    z.array(z.lazy(() => MessageContentContact$inboundSchema)),
  ),
  buttons: types.optional(z.array(z.lazy(() => Button$inboundSchema))),
  listButton: types.optional(types.string()),
  sections: types.optional(z.array(z.lazy(() => Section$inboundSchema))),
  emoji: types.optional(types.string()),
  reactToMessageId: types.optional(types.string()),
  templateId: types.optional(types.string()),
  templateVariables: types.optional(z.record(z.string(), types.string())),
});
/** @internal */
export type MessageContent$Outbound = {
  mediaUrl?: string | undefined;
  mediaId?: string | undefined;
  mimeType?: string | undefined;
  filename?: string | undefined;
  latitude?: number | undefined;
  longitude?: number | undefined;
  locationName?: string | undefined;
  locationAddress?: string | undefined;
  contacts?: Array<MessageContentContact$Outbound> | undefined;
  buttons?: Array<Button$Outbound> | undefined;
  listButton?: string | undefined;
  sections?: Array<Section$Outbound> | undefined;
  emoji?: string | undefined;
  reactToMessageId?: string | undefined;
  templateId?: string | undefined;
  templateVariables?: { [k: string]: string } | undefined;
};

/** @internal */
export const MessageContent$outboundSchema: z.ZodMiniType<
  MessageContent$Outbound,
  MessageContent
> = z.object({
  mediaUrl: z.optional(z.string()),
  mediaId: z.optional(z.string()),
  mimeType: z.optional(z.string()),
  filename: z.optional(z.string()),
  latitude: z.optional(z.number()),
  longitude: z.optional(z.number()),
  locationName: z.optional(z.string()),
  locationAddress: z.optional(z.string()),
  contacts: z.optional(
    z.array(z.lazy(() => MessageContentContact$outboundSchema)),
  ),
  buttons: z.optional(z.array(z.lazy(() => Button$outboundSchema))),
  listButton: z.optional(z.string()),
  sections: z.optional(z.array(z.lazy(() => Section$outboundSchema))),
  emoji: z.optional(z.string()),
  reactToMessageId: z.optional(z.string()),
  templateId: z.optional(z.string()),
  templateVariables: z.optional(z.record(z.string(), z.string())),
});

export function messageContentToJSON(messageContent: MessageContent): string {
  return JSON.stringify(MessageContent$outboundSchema.parse(messageContent));
}
export function messageContentFromJSON(
  jsonString: string,
): SafeParseResult<MessageContent, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => MessageContent$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'MessageContent' from JSON`,
  );
}
